name: DAST - Local App + OWASP ZAP

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main, develop ]
  workflow_dispatch:

permissions:
  contents: read
  actions: read

env:
  APP_IMAGE: local-app:latest
  APP_PORT: "8080"           # mude se sua app expõe outra porta
  APP_HEALTH_PATH: "/health" # mude se seu endpoint de saúde for diferente (use "/" se não tiver)
  WAIT_SECONDS: "180"        # tempo máximo (em segundos) para esperar a app ficar de pé

jobs:
  dast:
    runs-on: ubuntu-latest
    timeout-minutes: 60

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      # 1) Build da sua aplicação em Docker (precisa de um Dockerfile no repositório)
      - name: Build app image
        run: |
          docker build -t "${APP_IMAGE}" .

      # 2) Sobe a aplicação localmente, expondo na porta 8080 do host
      - name: Run app container
        run: |
          docker run -d --name local-app -p ${APP_PORT}:${APP_PORT} "${APP_IMAGE}"
          docker ps

      # 3) Espera (de forma resiliente) a app responder; não falha o job se não responder
      - name: Wait for local app (soft check)
        run: |
          URL="http://localhost:${APP_PORT}${APP_HEALTH_PATH}"
          echo "Waiting for ${URL} up to ${WAIT_SECONDS}s..."
          end=$((SECONDS + WAIT_SECONDS))
          ok=0
          while [ $SECONDS -lt $end ]; do
            code=$(curl -s -o /dev/null -w "%{http_code}" --max-time 3 "$URL" || echo "000")
            echo "HTTP $code"
            if [ "$code" = "200" ] || [ "$code" = "204" ] || [ "$code" = "302" ] || [ "$code" = "301" ]; then
              ok=1
              break
            fi
            sleep 3
          done
          if [ $ok -eq 1 ]; then
            echo "App is up."
          else
            echo "App did not become healthy in time. Proceeding anyway."  # não quebra o job
          fi

      # 4) ZAP Full Scan (action oficial). Não falha o job por findings.
      #    Alvo: http://localhost:8080 (ou a porta que você configurou)
      - name: ZAP Full Scan
        uses: zaproxy/action-full-scan@v0.8.0
        with:
          target: http://localhost:${{ env.APP_PORT }}
          cmd_options: >-
            -a -d
          allow_issue_writing: false
          fail_action: false
          artifact_name: zapreport   # evitar nomes com hífen

      # 5) Consolida relatórios (HTML/MD) em uma pasta e envia como artifact único
      - name: Collect ZAP artifacts
        if: always()
        run: |
          mkdir -p dast-reports
          cp -f report.html dast-reports/zap-report.html 2>/dev/null || true
          cp -f report.md   dast-reports/zap-report.md   2>/dev/null || true
          cp -f *.html      dast-reports/                2>/dev/null || true
          cp -f *.md        dast-reports/                2>/dev/null || true
          ls -lah dast-reports || true

      - name: Upload consolidated artifacts
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: dast-reports
          path: dast-reports

      # 6) Cleanup
      - name: Stop and remove app container
        if: always()
        run: |
          docker logs local-app || true
          docker rm -f local-app || true
